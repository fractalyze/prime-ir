diff --git a/mlir/lib/Dialect/Linalg/IR/LinalgInterfaces.cpp b/mlir/lib/Dialect/Linalg/IR/LinalgInterfaces.cpp
--- a/mlir/lib/Dialect/Linalg/IR/LinalgInterfaces.cpp
+++ b/mlir/lib/Dialect/Linalg/IR/LinalgInterfaces.cpp
@@ -26,6 +26,10 @@
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/Support/Casting.h"
 #include "llvm/Support/raw_ostream.h"
+#include "prime_ir/Dialect/EllipticCurve/IR/EllipticCurveOps.h"
+#include "prime_ir/Dialect/Field/IR/FieldOps.h"
+#include "prime_ir/Dialect/ModArith/IR/ModArithOps.h"
+using namespace ::mlir::prime_ir;
 #include <optional>

 using namespace mlir;
@@ -526,6 +530,9 @@ mlir::linalg::detail::isContractionInterfaceImpl(
   // TODO: more fields than add/mul.
   // clang-format off
   if (!::isContractionBody<
+        elliptic_curve::ScalarMulOp, elliptic_curve::AddOp,
+        mod_arith::MulOp, mod_arith::AddOp,
+        field::MulOp, field::AddOp,
         arith::MulFOp, arith::AddFOp,
         arith::MulIOp, arith::AddIOp,
         complex::MulOp, complex::AddOp,
diff --git a/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp b/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
--- a/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
+++ b/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
@@ -49,6 +49,14 @@
 #include "llvm/Support/LogicalResult.h"
 #include "llvm/Support/MathExtras.h"
 #include "llvm/Support/raw_ostream.h"
+#include "prime_ir/Dialect/EllipticCurve/IR/EllipticCurveOps.h"
+#include "prime_ir/Dialect/EllipticCurve/IR/EllipticCurveTypes.h"
+#include "prime_ir/Dialect/Field/IR/FieldOps.h"
+#include "prime_ir/Dialect/Field/IR/FieldTypes.h"
+#include "prime_ir/Dialect/ModArith/IR/ModArithOps.h"
+#include "prime_ir/Dialect/ModArith/IR/ModArithTypes.h"
+using namespace ::mlir::prime_ir;
+
 #include <cassert>
 #include <optional>

@@ -438,6 +446,14 @@ struct LinalgBackpropCompanionOpInterfaceHelper
 namespace {

 class RegionBuilderHelper {
+public:
+  using ModArithType = mod_arith::ModArithType;
+  using PrimeFieldType = field::PrimeFieldType;
+  using ExtensionFieldType = field::ExtensionFieldType;
+  using AffineType = elliptic_curve::AffineType;
+  using JacobianType = elliptic_curve::JacobianType;
+  using XYZZType = elliptic_curve::XYZZType;
+
 public:
   RegionBuilderHelper(OpBuilder &builder, Block &block)
       : builder(builder), block(block) {}
@@ -502,13 +518,22 @@ public:
     bool allComplex = isComplex(arg0) && isComplex(arg1);
     bool allFloatingPoint = isFloatingPoint(arg0) && isFloatingPoint(arg1);
     bool allInteger = isInteger(arg0) && isInteger(arg1);
-    bool allBool = allInteger && arg0.getType().getIntOrFloatBitWidth() == 1 &&
-                   arg1.getType().getIntOrFloatBitWidth() == 1;
-    if (!allComplex && !allFloatingPoint && !allInteger) {
+    bool allBool = allInteger &&
+                   arg0.getType().getIntOrFloatBitWidth() == 1 &&
+                   arg1.getType().getIntOrFloatBitWidth() == 1;
+
+    bool allModular = isModular(arg0) && isModular(arg1);
+    bool allField = isField(arg0) && isField(arg1);
+    bool scalarByPoint = (isPrimeField(arg0) && isECPoint(arg1)) ||
+                         (isECPoint(arg0) && isPrimeField(arg1));
+    bool allECPoint = isECPoint(arg0) && isECPoint(arg1);
+
+    if (!allComplex && !allFloatingPoint && !allInteger && !allModular &&
+        !allField && !scalarByPoint && !allECPoint) {
       if (emitError) {
         emitError()
             << "Cannot build binary Linalg operation: expects allComplex, "
-               "allFloatingPoint, or allInteger, got "
+               "allFloatingPoint, allInteger, allModular, allField, scalarByPoint, or allECPoint, got "
             << arg0.getType() << " and " << arg1.getType();
         return nullptr;
       }
@@ -524,6 +549,15 @@ public:
         return arith::AddFOp::create(builder, arg0.getLoc(), arg0, arg1);
       if (allBool)
         return arith::OrIOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (allModular)
+        return mod_arith::AddOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (allField)
+        return field::AddOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (scalarByPoint)
+        llvm_unreachable("unsupported operation: add with scalar and EC point");
+      if (allECPoint)
+        return elliptic_curve::AddOp::create(
+            builder, arg0.getLoc(), arg0.getType(), arg0, arg1);
       return arith::AddIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::sub:
       if (allComplex)
@@ -537,6 +571,15 @@ public:
         }
         llvm_unreachable("unsupported operation: sub with bools");
       }
+      if (allModular)
+        return mod_arith::SubOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (allField)
+        return field::SubOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (scalarByPoint)
+        llvm_unreachable("unsupported operation: sub with scalar and EC point");
+      if (allECPoint)
+        return elliptic_curve::SubOp::create(
+            builder, arg0.getLoc(), arg0.getType(), arg0, arg1);
       return arith::SubIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::mul:
       if (allComplex)
@@ -545,6 +588,19 @@ public:
         return arith::MulFOp::create(builder, arg0.getLoc(), arg0, arg1);
       if (allBool)
         return arith::AndIOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (allModular)
+        return mod_arith::MulOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (allField)
+        return field::MulOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (scalarByPoint) {
+        if (isECPoint(arg0))
+          return elliptic_curve::ScalarMulOp::create(
+              builder, arg0.getLoc(), arg0.getType(), arg1, arg0);
+        return elliptic_curve::ScalarMulOp::create(
+            builder, arg0.getLoc(), arg1.getType(), arg0, arg1);
+      }
+      if (allECPoint)
+        llvm_unreachable("unsupported operation: mul with two EC points");
       return arith::MulIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::div:
       if (allComplex)
@@ -558,6 +614,14 @@ public:
         }
         llvm_unreachable("unsupported operation: div with bools");
       }
+      if (allModular)
+        llvm_unreachable("unsupported operation: div with modular int");
+      if (allField)
+        llvm_unreachable("unsupported operation: div with field elements");
+      if (scalarByPoint)
+        llvm_unreachable("unsupported operation: div with scalar by EC points");
+      if (allECPoint)
+        llvm_unreachable("unsupported operation: div with two EC points");
       return arith::DivSIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::div_unsigned:
       if (!allInteger || allBool) {
@@ -567,18 +631,54 @@ public:
         }
         llvm_unreachable("unsupported operation: unsigned div not on uint");
       }
+      if (allModular)
+        llvm_unreachable("unsupported operation: div_unsigned with modular int");
+      if (allField)
+        llvm_unreachable("unsupported operation: div_unsigned with field elements");
+      if (scalarByPoint)
+        llvm_unreachable("unsupported operation: div_unsigned with scalar by EC points");
+      if (allECPoint)
+        llvm_unreachable("unsupported operation: div_unsigned with two EC points");
       return arith::DivUIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::max_signed:
       assert(!allComplex);
       if (allFloatingPoint)
         return arith::MaximumFOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (allModular)
+        llvm_unreachable("unsupported operation: max_signed with modular int");
+      if (allField)
+        llvm_unreachable("unsupported operation: max_signed with field elements");
+      if (scalarByPoint)
+        llvm_unreachable("unsupported operation: max_signed with scalar by EC points");
+      if (allECPoint)
+        llvm_unreachable("unsupported operation: max_signed with two EC points");
       return arith::MaxSIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::min_signed:
       assert(!allComplex);
       if (allFloatingPoint)
         return arith::MinimumFOp::create(builder, arg0.getLoc(), arg0, arg1);
+      if (allModular)
+        llvm_unreachable("unsupported operation: min_signed with modular int");
+      if (allField)
+        llvm_unreachable("unsupported operation: min_signed with field elements");
+      if (scalarByPoint)
+        llvm_unreachable("unsupported operation: min_signed with scalar by EC points");
+      if (allECPoint)
+        llvm_unreachable("unsupported operation: min_signed with two EC points");
       return arith::MinSIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::max_unsigned:
       assert(!allComplex);
@@ -588,6 +688,14 @@ public:
         }
         llvm_unreachable("unsupported operation: unsigned max not on uint");
       }
+      if (allModular)
+        llvm_unreachable("unsupported operation: max_unsigned with modular int");
+      if (allField)
+        llvm_unreachable("unsupported operation: max_unsigned with field elements");
+      if (scalarByPoint)
+        llvm_unreachable("unsupported operation: max_unsigned with scalar by EC points");
+      if (allECPoint)
+        llvm_unreachable("unsupported operation: max_unsigned with two EC points");
       return arith::MaxUIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::min_unsigned:
       assert(!allComplex);
@@ -597,6 +705,14 @@ public:
         }
         llvm_unreachable("unsupported operation: unsigned min not on uint");
       }
+      if (allModular)
+        llvm_unreachable("unsupported operation: min_unsigned with modular int");
+      if (allField)
+        llvm_unreachable("unsupported operation: min_unsigned with field elements");
+      if (scalarByPoint)
+        llvm_unreachable("unsupported operation: min_unsigned with scalar by EC points");
+      if (allECPoint)
+        llvm_unreachable("unsupported operation: min_unsigned with two EC points");
       return arith::MinUIOp::create(builder, arg0.getLoc(), arg0, arg1);
     case BinaryFn::powf:
       assert(allFloatingPoint);
@@ -635,6 +751,9 @@ public:
   // Build the type functions defined by OpDSL.
   Value buildTypeFn(TypeFn typeFn, Type toType, Value operand,
                     function_ref<InFlightDiagnostic()> emitError = {}) {
+    if (isField(operand) || isECPoint(operand) || isModular(operand)) {
+      return operand; // Do not cast PrimeIR types.
+    }
     switch (typeFn) {
     case TypeFn::cast_signed:
       return cast(toType, operand, false);
@@ -705,6 +824,21 @@ private:
   bool isInteger(Value value) {
     return llvm::isa<IntegerType>(value.getType());
   }
+  bool isModular(Value value) {
+    return llvm::isa<ModArithType>(value.getType());
+  }
+  bool isPrimeField(Value value) {
+    return llvm::isa<PrimeFieldType>(value.getType());
+  }
+  bool isField(Value value) {
+    return llvm::isa<PrimeFieldType>(value.getType()) ||
+           llvm::isa<ExtensionFieldType>(value.getType());
+  }
+  bool isECPoint(Value value) {
+    return llvm::isa<AffineType>(value.getType()) ||
+           llvm::isa<JacobianType>(value.getType()) ||
+           llvm::isa<XYZZType>(value.getType());
+  }

   OpBuilder &builder;
   Block &block;
diff --git a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
@@ -11406,4 +11406,7 @@ cc_library(
         ":ViewLikeInterface",
         "//llvm:Support",
+        "@prime_ir//prime_ir/Dialect/EllipticCurve/IR:EllipticCurve",
+        "@prime_ir//prime_ir/Dialect/Field/IR:Field",
+        "@prime_ir//prime_ir/Dialect/ModArith/IR:ModArith",
     ],
 )

