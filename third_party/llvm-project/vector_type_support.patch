diff --git a/mlir/lib/Dialect/Vector/IR/VectorOps.cpp b/mlir/lib/Dialect/Vector/IR/VectorOps.cpp
--- a/mlir/lib/Dialect/Vector/IR/VectorOps.cpp
+++ b/mlir/lib/Dialect/Vector/IR/VectorOps.cpp
@@ -39,6 +39,9 @@
 #include "mlir/Interfaces/ValueBoundsOpInterface.h"
 #include "mlir/Support/LLVM.h"
 #include "mlir/Transforms/InliningUtils.h"
+#include "prime_ir/Dialect/Field/IR/FieldOps.h"
+#include "prime_ir/Dialect/ModArith/IR/ModArithOps.h"
+#include "prime_ir/IR/Attributes.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallVector.h"
@@ -404,8 +407,18 @@ static Attribute convertNumericAttr(Attribute attr, Type expectedType) {
   // Integer-to-integer conversion
   if (auto intAttr = dyn_cast<IntegerAttr>(attr)) {
     if (auto intType = dyn_cast<IntegerType>(expectedType)) {
-      if (intAttr.getType() != expectedType)
+      if (intAttr.getType() != expectedType) {
+        if (auto fieldType =
+                dyn_cast<prime_ir::field::PrimeFieldType>(expectedType)) {
+          return IntegerAttr::get(fieldType.getStorageType(), intAttr.getInt());
+        } else if (auto modArithType =
+                       dyn_cast<prime_ir::mod_arith::ModArithType>(
+                           expectedType)) {
+          return IntegerAttr::get(modArithType.getStorageType(),
+                                  intAttr.getInt());
+        }
         return IntegerAttr::get(expectedType, intAttr.getInt());
+      }
     }
     return attr;
   }
@@ -496,6 +509,12 @@ void VectorDialect::initialize() {
 Operation *VectorDialect::materializeConstant(OpBuilder &builder,
                                               Attribute value, Type type,
                                               Location loc) {
+  if (auto op =
+          prime_ir::field::ConstantOp::materialize(builder, value, type, loc))
+    return op;
+  if (auto op = prime_ir::mod_arith::ConstantOp::materialize(builder, value,
+                                                             type, loc))
+    return op;
   if (isa<ub::PoisonAttrInterface>(value))
     return value.getDialect().materializeConstant(builder, value, type, loc);

@@ -2128,8 +2147,10 @@ static Attribute foldDenseElementsAttrSrcExtractOp(ExtractOp extractOp,

   if (denseAttr.isSplat()) {
     Attribute newAttr = denseAttr.getSplatValue<Attribute>();
-    if (auto vecDstType = dyn_cast<VectorType>(extractOp.getType()))
+    if (auto vecDstType = dyn_cast<VectorType>(extractOp.getType())) {
+      vecDstType = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(vecDstType));
       newAttr = DenseElementsAttr::get(vecDstType, newAttr);
+    }
     return newAttr;
   }

@@ -2160,6 +2181,7 @@ static Attribute foldDenseElementsAttrSrcExtractOp(ExtractOp extractOp,
   if (auto resVecTy = dyn_cast<VectorType>(extractOp.getType())) {
     SmallVector<Attribute> elementValues(
         denseValuesBegin, denseValuesBegin + resVecTy.getNumElements());
+    resVecTy = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(resVecTy));
     newAttr = DenseElementsAttr::get(resVecTy, elementValues);
   } else {
     newAttr = *denseValuesBegin;
@@ -2654,6 +2676,11 @@ static OpFoldResult foldFromElementsToConstant(FromElementsOp fromElementsOp,

   // DenseElementsAttr only supports int/index/float/complex types.
   auto destVecType = fromElementsOp.getDest().getType();
+  // Convert PrimeIR types to builtin types for DenseElementsAttr
+  VectorType convertedVecType =
+      cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(destVecType));
+  // Check element type of converted type (PrimeIR types have int storage)
+  auto convertedEltType = convertedVecType.getElementType();
   auto destEltType = destVecType.getElementType();
-  if (!destEltType.isIntOrIndexOrFloat() && !isa<ComplexType>(destEltType))
+  if (!convertedEltType.isIntOrIndexOrFloat() && !isa<ComplexType>(convertedEltType))
     return {};
@@ -2664,7 +2689,7 @@ static OpFoldResult foldFromElementsToConstant(FromElementsOp fromElementsOp,
     return convertNumericAttr(attr, destEltType);
   });

-  return DenseElementsAttr::get(destVecType, convertedElements);
+  return DenseElementsAttr::get(convertedVecType, convertedElements);
 }

 OpFoldResult FromElementsOp::fold(FoldAdaptor adaptor) {
@@ -3087,7 +3112,7 @@ OpFoldResult BroadcastOp::fold(FoldAdaptor adaptor) {

   if (!adaptor.getSource())
     return {};
-  auto vectorType = getResultVectorType();
+  auto vectorType = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(getResultVectorType()));
   if (auto attr = llvm::dyn_cast<IntegerAttr>(adaptor.getSource())) {
     if (vectorType.getElementType() != attr.getType())
       return {};
@@ -3253,9 +3278,9 @@ OpFoldResult vector::ShuffleOp::fold(FoldAdaptor adaptor) {
     }

     results.push_back(indexedElm);
-  }
-
-  return DenseElementsAttr::get(getResultVectorType(), results);
+  }
+  VectorType resType = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(getResultVectorType()));
+  return DenseElementsAttr::get(resType, results);
 }

 namespace {
@@ -3719,6 +3744,7 @@ foldDenseElementsAttrDestInsertOp(InsertOp insertOp, Attribute srcAttr,

   auto allValues = llvm::to_vector(denseDst.getValues<Attribute>());
   copy(insertedValues, allValues.begin() + insertBeginPosition);
+  destTy = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(destTy));
   auto newAttr = DenseElementsAttr::get(destTy, allValues);

   return newAttr;
@@ -4059,6 +4085,23 @@ public:
     } while (succeeded(
         incSlicePosition(currSlicePosition, sliceShape, sliceOffsets)));

+    if (auto modArithType = dyn_cast<prime_ir::mod_arith::ModArithType>(
+            destTy.getElementType())) {
+      VectorType converted =
+          cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(destTy));
+      auto newAttr = DenseElementsAttr::get(converted, newValues);
+      rewriter.replaceOpWithNewOp<prime_ir::mod_arith::ConstantOp>(op, destTy,
+                                                                   newAttr);
+      return success();
+    } else if (auto pfType = dyn_cast<prime_ir::field::PrimeFieldType>(
+                   destTy.getElementType())) {
+      VectorType converted =
+          cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(destTy));
+      auto newAttr = DenseElementsAttr::get(converted, newValues);
+      rewriter.replaceOpWithNewOp<prime_ir::field::ConstantOp>(op, destTy,
+                                                               newAttr);
+      return success();
+    }
     auto newAttr = DenseElementsAttr::get(destTy, newValues);
     rewriter.replaceOpWithNewOp<arith::ConstantOp>(op, newAttr);
     return success();
@@ -4410,6 +4453,7 @@ foldExtractStridedSliceNonSplatConstant(ExtractStridedSliceOp op,
   assert(static_cast<int64_t>(sliceValues.size()) ==
              sliceVecTy.getNumElements() &&
          "Invalid number of slice elements");
+  sliceVecTy = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(sliceVecTy));
   return DenseElementsAttr::get(sliceVecTy, sliceValues);
 }

@@ -4422,8 +4466,10 @@ OpFoldResult ExtractStridedSliceOp::fold(FoldAdaptor adaptor) {

   // ExtractStridedSliceOp(splat ConstantOp) -> ConstantOp.
   if (auto splat =
-          llvm::dyn_cast_if_present<SplatElementsAttr>(adaptor.getSource()))
-    return DenseElementsAttr::get(getType(), splat.getSplatValue<Attribute>());
+          llvm::dyn_cast_if_present<SplatElementsAttr>(adaptor.getSource())) {
+    VectorType destTy = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(getType()));
+    return DenseElementsAttr::get(destTy, splat.getSplatValue<Attribute>());
+  }

   // ExtractStridedSliceOp(non-splat ConstantOp) -> ConstantOp.
   return foldExtractStridedSliceNonSplatConstant(*this, adaptor.getSource());
diff --git a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
@@ -5119,6 +5119,9 @@ cc_library(
         ":VectorOpsIncGen",
         ":ViewLikeInterface",
         "//llvm:Support",
+        "@prime_ir//prime_ir/Dialect/Field/IR:Field",
+        "@prime_ir//prime_ir/Dialect/ModArith/IR:ModArith",
+        "@prime_ir//prime_ir/IR:Attributes",
     ],
 )

