diff --git a/mlir/lib/Dialect/Vector/IR/VectorOps.cpp b/mlir/lib/Dialect/Vector/IR/VectorOps.cpp
index 1fb8c7a928e0..bce5fd54a14d 100644
--- a/mlir/lib/Dialect/Vector/IR/VectorOps.cpp
+++ b/mlir/lib/Dialect/Vector/IR/VectorOps.cpp
@@ -38,6 +38,9 @@
 #include "mlir/Interfaces/ValueBoundsOpInterface.h"
 #include "mlir/Support/LLVM.h"
 #include "mlir/Transforms/InliningUtils.h"
+#include "prime_ir/Dialect/Field/IR/FieldOps.h"
+#include "prime_ir/Dialect/ModArith/IR/ModArithOps.h"
+#include "prime_ir/IR/Attributes.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallVector.h"
@@ -404,8 +407,17 @@ std::optional<int64_t> vector::getConstantVscaleMultiplier(Value value) {
 /// has the correct type, returns it unchanged.
 static Attribute convertIntegerAttr(Attribute attr, Type expectedType) {
   if (auto intAttr = mlir::dyn_cast<IntegerAttr>(attr)) {
-    if (intAttr.getType() != expectedType)
+    if (intAttr.getType() != expectedType) {
+      if (auto fieldType =
+              dyn_cast<prime_ir::field::PrimeFieldType>(expectedType)) {
+        return IntegerAttr::get(fieldType.getStorageType(), intAttr.getInt());
+      } else if (auto modArithType =
+                     dyn_cast<prime_ir::mod_arith::ModArithType>(expectedType)) {
+        return IntegerAttr::get(modArithType.getStorageType(),
+                                intAttr.getInt());
+      }
       return IntegerAttr::get(expectedType, intAttr.getInt());
+    }
   }
   return attr;
 }
@@ -481,6 +493,11 @@ void VectorDialect::initialize() {
 Operation *VectorDialect::materializeConstant(OpBuilder &builder,
                                               Attribute value, Type type,
                                               Location loc) {
+  if (auto op = prime_ir::field::ConstantOp::materialize(builder, value, type, loc))
+    return op;
+  if (auto op =
+          prime_ir::mod_arith::ConstantOp::materialize(builder, value, type, loc))
+    return op;
   if (isa<ub::PoisonAttrInterface>(value))
     return value.getDialect().materializeConstant(builder, value, type, loc);
 
@@ -2116,8 +2133,11 @@ static Attribute foldDenseElementsAttrSrcExtractOp(ExtractOp extractOp,
 
   if (denseAttr.isSplat()) {
     Attribute newAttr = denseAttr.getSplatValue<Attribute>();
-    if (auto vecDstType = dyn_cast<VectorType>(extractOp.getType()))
+    if (auto vecDstType = dyn_cast<VectorType>(extractOp.getType())) {
+      vecDstType =
+          cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(vecDstType));
       newAttr = DenseElementsAttr::get(vecDstType, newAttr);
+    }
     return newAttr;
   }
 
@@ -2149,6 +2169,7 @@ static Attribute foldDenseElementsAttrSrcExtractOp(ExtractOp extractOp,
   if (auto resVecTy = dyn_cast<VectorType>(extractOp.getType())) {
     SmallVector<Attribute> elementValues(
         denseValuesBegin, denseValuesBegin + resVecTy.getNumElements());
+    resVecTy = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(resVecTy));
     newAttr = DenseElementsAttr::get(resVecTy, elementValues);
   } else {
     newAttr = *denseValuesBegin;
@@ -2497,6 +2518,8 @@ static OpFoldResult foldFromElementsToConstant(FromElementsOp fromElementsOp,
     return convertIntegerAttr(attr, destEltType);
   });
 
+  destVecType =
+      cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(destVecType));
   return DenseElementsAttr::get(destVecType, convertedElements);
 }
 
@@ -2800,7 +2823,7 @@ BroadcastableToResult mlir::vector::isBroadcastableTo(
     Type srcType, VectorType dstVectorType,
     std::pair<VectorDim, VectorDim> *mismatchingDims) {
   // Broadcast scalar to vector of the same element type.
-  if (srcType.isIntOrIndexOrFloat() && dstVectorType &&
+  if (isa<VectorElementTypeInterface>(srcType) && dstVectorType &&
       getElementTypeOrSelf(srcType) == getElementTypeOrSelf(dstVectorType))
     return BroadcastableToResult::Success;
   // From now on, only vectors broadcast.
@@ -2878,7 +2901,8 @@ OpFoldResult BroadcastOp::fold(FoldAdaptor adaptor) {
     return getSource();
   if (!adaptor.getSource())
     return {};
-  auto vectorType = getResultVectorType();
+  VectorType vectorType = cast<VectorType>(
+      prime_ir::maybeConvertPrimeIRToBuiltinType(getResultVectorType()));
   if (auto attr = llvm::dyn_cast<IntegerAttr>(adaptor.getSource())) {
     if (vectorType.getElementType() != attr.getType())
       return {};
@@ -3058,8 +3082,9 @@ OpFoldResult vector::ShuffleOp::fold(FoldAdaptor adaptor) {
 
     results.push_back(indexedElm);
   }
-
-  return DenseElementsAttr::get(getResultVectorType(), results);
+  VectorType resType = cast<VectorType>(
+      prime_ir::maybeConvertPrimeIRToBuiltinType(getResultVectorType()));
+  return DenseElementsAttr::get(resType, results);
 }
 
 namespace {
@@ -3207,7 +3232,9 @@ OpFoldResult vector::InsertElementOp::fold(FoldAdaptor adaptor) {
     return {};
   results[posIdx] = src;
 
-  return DenseElementsAttr::get(getDestVectorType(), results);
+  VectorType destType = cast<VectorType>(
+      prime_ir::maybeConvertPrimeIRToBuiltinType(getDestVectorType()));
+  return DenseElementsAttr::get(destType, results);
 }
 
 //===----------------------------------------------------------------------===//
@@ -3382,6 +3409,7 @@ foldDenseElementsAttrDestInsertOp(InsertOp insertOp, Attribute srcAttr,
 
   auto allValues = llvm::to_vector(denseDst.getValues<Attribute>());
   copy(insertedValues, allValues.begin() + insertBeginPosition);
+  destTy = cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(destTy));
   auto newAttr = DenseElementsAttr::get(destTy, allValues);
 
   return newAttr;
@@ -3711,6 +3739,15 @@ public:
     } while (succeeded(
         incSlicePosition(currSlicePosition, sliceShape, sliceOffsets)));
 
+    if (auto modArithType =
+            dyn_cast<prime_ir::mod_arith::ModArithType>(destTy.getElementType())) {
+      VectorType converted =
+          cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(destTy));
+      auto newAttr = DenseElementsAttr::get(converted, newValues);
+      rewriter.replaceOpWithNewOp<prime_ir::mod_arith::ConstantOp>(op, destTy,
+                                                               newAttr);
+      return success();
+    }
     auto newAttr = DenseElementsAttr::get(destTy, newValues);
     rewriter.replaceOpWithNewOp<arith::ConstantOp>(op, newAttr);
     return success();
@@ -4057,6 +4094,8 @@ foldExtractStridedSliceNonSplatConstant(ExtractStridedSliceOp op,
   assert(static_cast<int64_t>(sliceValues.size()) ==
              sliceVecTy.getNumElements() &&
          "Invalid number of slice elements");
+  sliceVecTy =
+      cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(sliceVecTy));
   return DenseElementsAttr::get(sliceVecTy, sliceValues);
 }
 
@@ -4068,8 +4107,11 @@ OpFoldResult ExtractStridedSliceOp::fold(FoldAdaptor adaptor) {
 
   // ExtractStridedSliceOp(splat ConstantOp) -> ConstantOp.
   if (auto splat =
-          llvm::dyn_cast_if_present<SplatElementsAttr>(adaptor.getVector()))
-    DenseElementsAttr::get(getType(), splat.getSplatValue<Attribute>());
+          llvm::dyn_cast_if_present<SplatElementsAttr>(adaptor.getVector())) {
+    VectorType destTy =
+        cast<VectorType>(prime_ir::maybeConvertPrimeIRToBuiltinType(getType()));
+    return DenseElementsAttr::get(destTy, splat.getSplatValue<Attribute>());
+  }
 
   // ExtractStridedSliceOp(non-splat ConstantOp) -> ConstantOp.
   return foldExtractStridedSliceNonSplatConstant(*this, adaptor.getVector());
@@ -7080,7 +7122,9 @@ OpFoldResult SplatOp::fold(FoldAdaptor adaptor) {
     return {};
 
   // SplatElementsAttr::get treats single value for second arg as being a splat.
-  return SplatElementsAttr::get(getType(), {constOperand});
+  ShapedType destType =
+      cast<ShapedType>(prime_ir::maybeConvertPrimeIRToBuiltinType(getType()));
+  return SplatElementsAttr::get(destType, {constOperand});
 }
 
 void SplatOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
diff --git a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
index e86158d51727..a18225d441de 100644
--- a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
@@ -4713,6 +4713,9 @@ cc_library(
         ":VectorOpsIncGen",
         ":ViewLikeInterface",
         "//llvm:Support",
+        "@prime_ir//prime_ir/Dialect/Field/IR:FieldHdrs",
+        "@prime_ir//prime_ir/Dialect/ModArith/IR:ModArithHdrs",
+        "@prime_ir//prime_ir/IR:Attributes",
     ],
 )
 
