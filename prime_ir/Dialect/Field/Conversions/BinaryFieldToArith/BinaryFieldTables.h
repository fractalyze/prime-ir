/* Copyright 2026 The PrimeIR Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#ifndef PRIME_IR_DIALECT_FIELD_CONVERSIONS_BINARYFIELDTOARITH_BINARYFIELDTABLES_H_
#define PRIME_IR_DIALECT_FIELD_CONVERSIONS_BINARYFIELDTOARITH_BINARYFIELDTABLES_H_

#include <cstdint>

namespace mlir::prime_ir::field {

//===----------------------------------------------------------------------===//
// Tower Alpha Constants
//===----------------------------------------------------------------------===//
//
// Tower alpha constants from zk_dtypes.
// These are the elements satisfying x² + x + α = 0 at each tower level.
// Level 0 (GF(2)) has no α.

constexpr uint64_t kTowerAlphas[8] = {
    0,                      // Level 0: GF(2), no extension
    1,                      // Level 1: x² + x + 1
    2,                      // Level 2: x² + x + 2
    8,                      // Level 3: x² + x + 8
    128,                    // Level 4: x² + x + 128
    32768,                  // Level 5: x² + x + 32768
    2147483648ULL,          // Level 6: x² + x + 2³¹
    9223372036854775808ULL, // Level 7: x² + x + 2⁶³
};

//===----------------------------------------------------------------------===//
// Tower <-> AES Field Isomorphism Tables
//===----------------------------------------------------------------------===//
//
// The AES field uses the irreducible polynomial x⁸ + x⁴ + x³ + x + 1 (0x11B)
// Our binary tower field at level 3 uses recursive extension polynomials:
//   Level 1: X² + X + 1 (α = 1)
//   Level 2: X² + X + 2 (α = 2)
//   Level 3: X² + X + 8 (α = 8)
//
// Source: Binius project
// - binius/crates/field/src/arch/x86_64/gfni/gfni_arithmetics.rs
// - binius/crates/field/src/arch/aarch64/simd_arithmetic.rs

// 8x8 binary transformation matrix: Tower field -> AES field
// Each byte represents a row of the matrix (LSB = column 0)
// For use with x86 vgf2p8affineqb instruction
constexpr uint8_t kTowerToAesMatrix[8] = {
    0x3E, // 0b00111110
    0x98, // 0b10011000
    0x4E, // 0b01001110
    0x96, // 0b10010110
    0xEA, // 0b11101010
    0x6A, // 0b01101010
    0x50, // 0b01010000
    0x31, // 0b00110001
};

// 8x8 binary transformation matrix: AES field -> Tower field
constexpr uint8_t kAesToTowerMatrix[8] = {
    0x0C, // 0b00001100
    0x70, // 0b01110000
    0xA2, // 0b10100010
    0x72, // 0b01110010
    0x3E, // 0b00111110
    0x86, // 0b10000110
    0xE8, // 0b11101000
    0xD1, // 0b11010001
};

// 256-entry lookup table for Tower -> AES field conversion
// For use on ARM where GFNI is not available
// clang-format off
constexpr uint8_t kTowerToAesLookupTable[256] = {
    0x00, 0x01, 0xBC, 0xBD, 0xB0, 0xB1, 0x0C, 0x0D,
    0xEC, 0xED, 0x50, 0x51, 0x5C, 0x5D, 0xE0, 0xE1,
    0xD3, 0xD2, 0x6F, 0x6E, 0x63, 0x62, 0xDF, 0xDE,
    0x3F, 0x3E, 0x83, 0x82, 0x8F, 0x8E, 0x33, 0x32,
    0x8D, 0x8C, 0x31, 0x30, 0x3D, 0x3C, 0x81, 0x80,
    0x61, 0x60, 0xDD, 0xDC, 0xD1, 0xD0, 0x6D, 0x6C,
    0x5E, 0x5F, 0xE2, 0xE3, 0xEE, 0xEF, 0x52, 0x53,
    0xB2, 0xB3, 0x0E, 0x0F, 0x02, 0x03, 0xBE, 0xBF,
    0x2E, 0x2F, 0x92, 0x93, 0x9E, 0x9F, 0x22, 0x23,
    0xC2, 0xC3, 0x7E, 0x7F, 0x72, 0x73, 0xCE, 0xCF,
    0xFD, 0xFC, 0x41, 0x40, 0x4D, 0x4C, 0xF1, 0xF0,
    0x11, 0x10, 0xAD, 0xAC, 0xA1, 0xA0, 0x1D, 0x1C,
    0xA3, 0xA2, 0x1F, 0x1E, 0x13, 0x12, 0xAF, 0xAE,
    0x4F, 0x4E, 0xF3, 0xF2, 0xFF, 0xFE, 0x43, 0x42,
    0x70, 0x71, 0xCC, 0xCD, 0xC0, 0xC1, 0x7C, 0x7D,
    0x9C, 0x9D, 0x20, 0x21, 0x2C, 0x2D, 0x90, 0x91,
    0x58, 0x59, 0xE4, 0xE5, 0xE8, 0xE9, 0x54, 0x55,
    0xB4, 0xB5, 0x08, 0x09, 0x04, 0x05, 0xB8, 0xB9,
    0x8B, 0x8A, 0x37, 0x36, 0x3B, 0x3A, 0x87, 0x86,
    0x67, 0x66, 0xDB, 0xDA, 0xD7, 0xD6, 0x6B, 0x6A,
    0xD5, 0xD4, 0x69, 0x68, 0x65, 0x64, 0xD9, 0xD8,
    0x39, 0x38, 0x85, 0x84, 0x89, 0x88, 0x35, 0x34,
    0x06, 0x07, 0xBA, 0xBB, 0xB6, 0xB7, 0x0A, 0x0B,
    0xEA, 0xEB, 0x56, 0x57, 0x5A, 0x5B, 0xE6, 0xE7,
    0x76, 0x77, 0xCA, 0xCB, 0xC6, 0xC7, 0x7A, 0x7B,
    0x9A, 0x9B, 0x26, 0x27, 0x2A, 0x2B, 0x96, 0x97,
    0xA5, 0xA4, 0x19, 0x18, 0x15, 0x14, 0xA9, 0xA8,
    0x49, 0x48, 0xF5, 0xF4, 0xF9, 0xF8, 0x45, 0x44,
    0xFB, 0xFA, 0x47, 0x46, 0x4B, 0x4A, 0xF7, 0xF6,
    0x17, 0x16, 0xAB, 0xAA, 0xA7, 0xA6, 0x1B, 0x1A,
    0x28, 0x29, 0x94, 0x95, 0x98, 0x99, 0x24, 0x25,
    0xC4, 0xC5, 0x78, 0x79, 0x74, 0x75, 0xC8, 0xC9,
};

// 256-entry lookup table for AES -> Tower field conversion
constexpr uint8_t kAesToTowerLookupTable[256] = {
    0x00, 0x01, 0x3C, 0x3D, 0x8C, 0x8D, 0xB0, 0xB1,
    0x8A, 0x8B, 0xB6, 0xB7, 0x06, 0x07, 0x3A, 0x3B,
    0x59, 0x58, 0x65, 0x64, 0xD5, 0xD4, 0xE9, 0xE8,
    0xD3, 0xD2, 0xEF, 0xEE, 0x5F, 0x5E, 0x63, 0x62,
    0x7A, 0x7B, 0x46, 0x47, 0xF6, 0xF7, 0xCA, 0xCB,
    0xF0, 0xF1, 0xCC, 0xCD, 0x7C, 0x7D, 0x40, 0x41,
    0x23, 0x22, 0x1F, 0x1E, 0xAF, 0xAE, 0x93, 0x92,
    0xA9, 0xA8, 0x95, 0x94, 0x25, 0x24, 0x19, 0x18,
    0x55, 0x54, 0x69, 0x68, 0xD9, 0xD8, 0xE5, 0xE4,
    0xDF, 0xDE, 0xE3, 0xE2, 0x53, 0x52, 0x6F, 0x6E,
    0x0C, 0x0D, 0x30, 0x31, 0x80, 0x81, 0xBC, 0xBD,
    0x86, 0x87, 0xBA, 0xBB, 0x0A, 0x0B, 0x36, 0x37,
    0x2F, 0x2E, 0x13, 0x12, 0xA3, 0xA2, 0x9F, 0x9E,
    0xA5, 0xA4, 0x99, 0x98, 0x29, 0x28, 0x15, 0x14,
    0x76, 0x77, 0x4A, 0x4B, 0xFA, 0xFB, 0xC6, 0xC7,
    0xFC, 0xFD, 0xC0, 0xC1, 0x70, 0x71, 0x4C, 0x4D,
    0x26, 0x27, 0x1A, 0x1B, 0xAA, 0xAB, 0x96, 0x97,
    0xAC, 0xAD, 0x90, 0x91, 0x20, 0x21, 0x1C, 0x1D,
    0x7F, 0x7E, 0x43, 0x42, 0xF3, 0xF2, 0xCF, 0xCE,
    0xF5, 0xF4, 0xC9, 0xC8, 0x79, 0x78, 0x45, 0x44,
    0x5C, 0x5D, 0x60, 0x61, 0xD0, 0xD1, 0xEC, 0xED,
    0xD6, 0xD7, 0xEA, 0xEB, 0x5A, 0x5B, 0x66, 0x67,
    0x05, 0x04, 0x39, 0x38, 0x89, 0x88, 0xB5, 0xB4,
    0x8F, 0x8E, 0xB3, 0xB2, 0x03, 0x02, 0x3F, 0x3E,
    0x73, 0x72, 0x4F, 0x4E, 0xFF, 0xFE, 0xC3, 0xC2,
    0xF9, 0xF8, 0xC5, 0xC4, 0x75, 0x74, 0x49, 0x48,
    0x2A, 0x2B, 0x16, 0x17, 0xA6, 0xA7, 0x9A, 0x9B,
    0xA0, 0xA1, 0x9C, 0x9D, 0x2C, 0x2D, 0x10, 0x11,
    0x09, 0x08, 0x35, 0x34, 0x85, 0x84, 0xB9, 0xB8,
    0x83, 0x82, 0xBF, 0xBE, 0x0F, 0x0E, 0x33, 0x32,
    0x50, 0x51, 0x6C, 0x6D, 0xDC, 0xDD, 0xE0, 0xE1,
    0xDA, 0xDB, 0xE6, 0xE7, 0x56, 0x57, 0x6A, 0x6B,
};
// clang-format on

//===----------------------------------------------------------------------===//
// Utility Functions
//===----------------------------------------------------------------------===//

// Pack 8-byte matrix into 64-bit value for vgf2p8affineqb instruction.
// The matrix is stored in column-major order for the affine instruction.
inline uint64_t packMatrixForAffine(const uint8_t matrix[8]) {
  uint64_t result = 0;
  for (int i = 0; i < 8; ++i) {
    result |= static_cast<uint64_t>(matrix[i]) << (i * 8);
  }
  return result;
}

// Get the packed Tower->AES transformation matrix for GFNI.
inline uint64_t getTowerToAesMatrixPacked() {
  return packMatrixForAffine(kTowerToAesMatrix);
}

// Get the packed AES->Tower transformation matrix for GFNI.
inline uint64_t getAesToTowerMatrixPacked() {
  return packMatrixForAffine(kAesToTowerMatrix);
}

//===----------------------------------------------------------------------===//
// Tower Polynomial Reduction Constants
//===----------------------------------------------------------------------===//
//
// Tower reduction polynomials for various tower levels:
// - Level 6 (64-bit):  x⁶⁴ + x⁴ + x³ + x + 1
// - Level 7 (128-bit): x¹²⁸ + x⁷ + x² + x + 1
//
// For reduction, we compute: high * (low_terms) where low_terms excludes xⁿ.
// E.g., for x¹²⁸ + x⁷ + x² + x + 1:
//   high * (x⁷ + x² + x + 1) = (high << 7) ^ (high << 2) ^ (high << 1) ^ high

// Reduction terms for tower level 6: x⁶⁴ + x⁴ + x³ + x + 1
// Returns shifts needed: {4, 3, 1, 0} (0 means just the value itself)
constexpr unsigned kTowerLevel6ReductionShifts[] = {4, 3, 1, 0};
constexpr unsigned kTowerLevel6ReductionShiftCount = 4;
constexpr unsigned kTowerLevel6OverflowShifts[] = {60, 61, 63}; // 64 - shift
constexpr unsigned kTowerLevel6OverflowShiftCount = 3;

// Reduction terms for tower level 7: x¹²⁸ + x⁷ + x² + x + 1
// Returns shifts needed: {7, 2, 1, 0}
constexpr unsigned kTowerLevel7ReductionShifts[] = {7, 2, 1, 0};
constexpr unsigned kTowerLevel7ReductionShiftCount = 4;
constexpr unsigned kTowerLevel7OverflowShifts[] = {57, 62, 63}; // 64 - shift
constexpr unsigned kTowerLevel7OverflowShiftCount = 3;

} // namespace mlir::prime_ir::field

// NOLINTNEXTLINE(whitespace/line_length)
#endif // PRIME_IR_DIALECT_FIELD_CONVERSIONS_BINARYFIELDTOARITH_BINARYFIELDTABLES_H_
